const TelegramBot = require('node-telegram-bot-api');
const config = require('./config');
const ContractService = require('./contractService');
const WalletService = require('./walletService');
const SimpleServer = require('./simpleServer');

class TelegramMembershipBot {
  constructor() {
    this.bot = new TelegramBot(config.telegramBotToken, { polling: true });
    this.contractService = new ContractService();
    this.walletService = new WalletService();
    this.me = { username: 'ChainsxCo_bot' };
    
    // Start simple API server for connection status
    this.apiServer = new SimpleServer(this.walletService, 3001);
    
    // Listen for wallet connection events
    this.walletService.on('walletConnected', (data) => {
      this.handleWalletConnectedEvent(data);
    });
    
    this.setupCommands();
    this.setupErrorHandling();
    this.startCleanupTimer();
    this.initializeBot();
  }

  async initializeBot() {
    try {
      // Start API server
      await this.apiServer.start();
      
      this.me = await this.bot.getMe();
      console.log(`ü§ñ Bot username loaded: @${this.me.username}`);
    } catch (err) {
      console.warn('‚ö†Ô∏è Initialization error:', err.message);
      this.me = { username: 'ChainsxCo_bot' };
    }
  }

  async handleWalletConnectedEvent(data) {
    try {
      console.log(`üì® Received walletConnected event:`, data);
      await this.handleWalletConnected(data.telegramUserId, data.address, data.chainId);
    } catch (error) {
      console.error('Error handling wallet connected event:', error);
    }
  }

  setupCommands() {
    // Basic Commands
    this.bot.onText(/\/start(?:\s+ref_(0x[a-fA-F0-9]{40}))?/, (msg, match) => this.handleStart(msg, match));
    this.bot.onText(/\/help/, (msg) => this.handleHelp(msg));

    // Wallet Commands
    this.bot.onText(/\/connect/, (msg) => this.handleConnect(msg));
    this.bot.onText(/\/disconnect/, (msg) => this.handleDisconnect(msg));
    this.bot.onText(/\/wallet/, (msg) => this.handleWalletStatus(msg));

    // Member Commands  
    this.bot.onText(/\/register\s+(\d+)(?:\s+(0x[a-fA-F0-9]{40}))?/, (msg, match) => this.handleRegister(msg, match));
    this.bot.onText(/\/upgrade (.+)/, (msg, match) => this.handleUpgrade(msg, match));
    this.bot.onText(/\/myinfo/, (msg) => this.handleMyInfo(msg));

    // Plan Information Commands
    this.bot.onText(/\/planinfo (.+)/, (msg, match) => this.handlePlanInfo(msg, match));
    this.bot.onText(/\/totalplans/, (msg) => this.handleTotalPlans(msg));
    this.bot.onText(/\/allplans/, (msg) => this.handleAllPlans(msg));

    // Contract Status Commands
    this.bot.onText(/\/contractstatus/, (msg) => this.handleContractStatus(msg));
    this.bot.onText(/\/usdtbalance/, (msg) => this.handleUSDTBalance(msg));

    // Validation Commands
    this.bot.onText(/\/validate (.+) (.+)/, (msg, match) => this.handleValidateRegistration(msg, match));
    this.bot.onText(/\/validateupgrade (.+)/, (msg, match) => this.handleValidateUpgrade(msg, match));
    this.bot.onText(/\/approve (.+)/, (msg, match) => this.handleApproveUSDT(msg, match));

    // Transaction Status
    this.bot.onText(/\/txstatus (.+)/, (msg, match) => this.handleTransactionStatus(msg, match));

    // Referral Commands
    this.bot.onText(/\/getreferrallink/, (msg) => this.handleReferralLink(msg));

    // Callback query handlers for inline buttons
    this.bot.on('callback_query', (callbackQuery) => this.handleCallbackQuery(callbackQuery));
  }

  setupErrorHandling() {
    this.bot.on('polling_error', (error) => {
      console.error('User Bot Polling error:', error);
    });

    process.on('unhandledRejection', (reason, promise) => {
      console.error('User Bot Unhandled Rejection at:', promise, 'reason:', reason);
    });
  }

  startCleanupTimer() {
    setInterval(() => {
      this.walletService.cleanupExpiredSessions();
    }, 10 * 60 * 1000);
  }

  async sendMessage(chatId, text, options = {}) {
    try {
      return await this.bot.sendMessage(chatId, text, {
        parse_mode: 'Markdown',
        ...options
      });
    } catch (error) {
      console.error('Error sending message:', error);
      return await this.bot.sendMessage(chatId, text.replace(/[*_`]/g, ''));
    }
  }

  async sendPhoto(chatId, photo, options = {}) {
    try {
      return await this.bot.sendPhoto(chatId, photo, {
        parse_mode: 'Markdown',
        ...options
      });
    } catch (error) {
      console.error('Error sending photo:', error);
      throw error;
    }
  }

  // === WALLET CONNECTION HANDLERS ===

  async handleConnect(msg) {
    const chatId = msg.chat.id;
    const userId = msg.from.id;

    try {
      const existingConnection = await this.walletService.checkConnection(userId);
      if (existingConnection.connected) {
        await this.sendMessage(chatId, `
‚úÖ *Wallet Already Connected*

üîó Address: \`${existingConnection.address}\`
üåê Network: ${config.networkName}

üí° *Commands:*
‚Ä¢ \`/wallet\` - View wallet info
‚Ä¢ \`/disconnect\` - Disconnect wallet
‚Ä¢ \`/myinfo\` - View membership info
        `);
        return;
      }

      await this.sendMessage(chatId, '‚è≥ Creating wallet connection...');

      const session = await this.walletService.createWalletConnectSession(userId);
      
      console.log(`üîó Session created for user ${userId}:`);
      console.log(`   Session ID: ${session.sessionId}`);
      console.log(`   URI length: ${session.uri.length}`);
      console.log(`   URI preview: ${session.uri.substring(0, 50)}...`);
      
      const platform = this.walletService.detectPlatform(msg);

      if (platform.isMobile) {
        await this.sendMobileWalletOptions(chatId, session.uri, userId, session.sessionId);
      } else {
        await this.sendDesktopWalletOptions(chatId, session.uri, userId, session.sessionId);
      }

      // Start polling for connection status
      this.startConnectionPolling(chatId, userId);

      setTimeout(async () => {
        const connection = await this.walletService.checkConnection(userId);
        if (!connection.connected) {
          await this.sendMessage(chatId, `
‚è∞ *Connection Timeout*

Connection request expired. Please try again with \`/connect\`

üí° *Tips for successful connection:*
‚Ä¢ Make sure your wallet app is updated
‚Ä¢ Check your internet connection  
‚Ä¢ Try using the web interface
‚Ä¢ Use QR code scanning when available
‚Ä¢ Allow the page to auto-close after connection

üîß *Troubleshooting:*
‚Ä¢ Ensure you're on ${config.networkName}
‚Ä¢ Clear browser cache if needed
‚Ä¢ Try different wallet apps
‚Ä¢ Check if popup blocker is disabled
          `);
        }
      }, 5 * 60 * 1000);

    } catch (error) {
      console.error('Connect error:', error);
      await this.sendMessage(chatId, `‚ùå Error creating wallet connection: ${error.message}

üí° Please try again with \`/connect\`

üîß If the issue persists:
‚Ä¢ Check your internet connection
‚Ä¢ Try using a different device
‚Ä¢ Contact support if needed`);
    }
  }

  // Modified connection polling - reduce frequency since we have events
  startConnectionPolling(chatId, userId) {
    const maxPolls = 36; // Poll for 36 * 10 = 360 seconds (6 minutes)
    let pollCount = 0;
    
    const pollInterval = setInterval(async () => {
      pollCount++;
      
      try {
        const connection = await this.walletService.checkConnection(userId);
        
        if (connection.connected) {
          clearInterval(pollInterval);
          
          // Send success message if not already sent by event
          await this.handleWalletConnected(userId, connection.address, connection.chainId);
          
          console.log(`‚úÖ Wallet connection detected via polling for user ${userId} after ${pollCount * 10} seconds`);
        } else if (pollCount >= maxPolls) {
          clearInterval(pollInterval);
          console.log(`‚è∞ Connection polling timeout for user ${userId}`);
        }
        
      } catch (error) {
        console.error('Error during connection polling:', error);
        if (pollCount >= maxPolls) {
          clearInterval(pollInterval);
        }
      }
    }, 10000); // Poll every 10 seconds (less frequent since we have events)
  }

  async sendMobileWalletOptions(chatId, uri, userId, sessionId) {
    // For production, use domain. For development, send URI directly
    const isProduction = process.env.NODE_ENV === 'production';
    const serverUrl = process.env.SERVER_URL || 'https://chainsx.info';
    
    if (isProduction && serverUrl.startsWith('https://')) {
      // Production: use HTTPS URL
      const connectUrl = `${serverUrl}/connect.html?uri=${encodeURIComponent(uri)}&userId=${userId}&sessionId=${sessionId}`;
      
      const keyboard = {
        inline_keyboard: [
          [
            { text: 'üöÄ Connect Wallet (One-Click)', url: connectUrl }
          ],
          [
            { text: 'üìã Copy URI', callback_data: 'copy_uri' },
            { text: '‚ùì Help', callback_data: 'connection_help' }
          ]
        ]
      };

      await this.sendMessage(chatId, `
üîó *Connect Your Wallet*

**Click the button below to connect:**

‚ö†Ô∏è *Important:*
‚Ä¢ Make sure you're on ${config.networkName}
‚Ä¢ Connection expires in 5 minutes
‚Ä¢ Page will auto-close after connection

üí° *Tip:* You'll automatically return to this chat!
      `, { reply_markup: keyboard });
    } else {
      // Development: send URI directly without button
      await this.sendMessage(chatId, `
üîó *Connect Your Wallet*

**Development Mode - Manual Connection:**

1Ô∏è‚É£ **Copy this URI:**
\`${uri}\`

2Ô∏è‚É£ **Open your wallet app**
3Ô∏è‚É£ **Find "WalletConnect" or "Connect to DApp"**
4Ô∏è‚É£ **Paste the URI**
5Ô∏è‚É£ **Approve the connection**

**Or visit connection page:**
${process.env.SERVER_URL || 'http://localhost:3001'}/connect.html?userId=${userId}&sessionId=${sessionId}

‚ö†Ô∏è *Important:*
‚Ä¢ Make sure you're on ${config.networkName}
‚Ä¢ Connection expires in 5 minutes

üí° *For production, set SERVER_URL to HTTPS domain in .env*
      `, { 
        reply_markup: {
          inline_keyboard: [
            [
              { text: 'üìã Copy URI', callback_data: 'copy_uri' },
              { text: '‚ùì Help', callback_data: 'connection_help' }
            ]
          ]
        }
      });
    }
  }

  async sendDesktopWalletOptions(chatId, uri, userId, sessionId) {
    const isProduction = process.env.NODE_ENV === 'production';
    const serverUrl = process.env.SERVER_URL || 'https://chainsx.info';
    
    try {
      const qrCodeBuffer = await this.walletService.generateQRCode(uri);
      
      if (isProduction && serverUrl.startsWith('https://')) {
        // Production: use HTTPS URL with button
        const connectUrl = `${serverUrl}/connect.html?uri=${encodeURIComponent(uri)}&userId=${userId}&sessionId=${sessionId}`;

        const keyboard = {
          inline_keyboard: [
            [
              { text: 'üöÄ Open Connection Page', url: connectUrl }
            ],
            [
              { text: 'üìã Copy URI', callback_data: 'copy_uri' },
              { text: '‚ùì Help', callback_data: 'connection_help' }
            ]
          ]
        };

        await this.sendPhoto(chatId, qrCodeBuffer, {
          caption: `
üîó *Connect Your Wallet*

**Option 1: Connection Page (Recommended)**
üöÄ Click "Open Connection Page" for full interface

**Option 2: QR Code**
üì± Scan QR code with your mobile wallet

‚ö†Ô∏è *Network:* ${config.networkName}
‚è∞ *Timeout:* 5 minutes
          `,
          reply_markup: keyboard
        });
      } else {
        // Development: show QR and manual instructions
        await this.sendPhoto(chatId, qrCodeBuffer, {
          caption: `
üîó *Connect Your Wallet*

**Option 1: QR Code**
üì± Scan QR code with your mobile wallet

**Option 2: Manual Connection**
Visit: ${process.env.SERVER_URL || 'http://localhost:3001'}/connect.html?userId=${userId}&sessionId=${sessionId}

**Option 3: Copy URI**
Use the "Copy URI" button below

‚ö†Ô∏è *Network:* ${config.networkName}
‚è∞ *Timeout:* 5 minutes

üí° *Note:* For Telegram buttons, set SERVER_URL to HTTPS domain
          `,
          reply_markup: {
            inline_keyboard: [
              [
                { text: 'üìã Copy URI', callback_data: 'copy_uri' },
                { text: '‚ùì Help', callback_data: 'connection_help' }
              ]
            ]
          }
        });
      }

    } catch (error) {
      console.error('Error sending QR code:', error);
      
      // Fallback without QR
      await this.sendMessage(chatId, `
üîó *Connect Your Wallet*

**Manual Connection:**

**WalletConnect URI:**
\`${uri}\`

**Connection Page:**
${process.env.SERVER_URL || 'http://localhost:3001'}/connect.html?userId=${userId}&sessionId=${sessionId}

**Instructions:**
1. Copy the URI above
2. Open your wallet app
3. Find "WalletConnect" or "Connect to DApp"
4. Paste the URI
5. Approve the connection

‚ö†Ô∏è *Network:* ${config.networkName}
‚è∞ *Timeout:* 5 minutes
      `, {
        reply_markup: {
          inline_keyboard: [
            [
              { text: 'üìã Copy URI', callback_data: 'copy_uri' }
            ]
          ]
        }
      });
    }
  }

  async handleCallbackQuery(callbackQuery) {
    const chatId = callbackQuery.message.chat.id;
    const userId = callbackQuery.from.id;
    const data = callbackQuery.data;

    try {
      await this.bot.answerCallbackQuery(callbackQuery.id);

      switch (data) {
        case 'copy_uri':
          const sessionId = this.walletService.userSessions.get(userId);
          if (sessionId) {
            const session = this.walletService.sessions.get(sessionId);
            if (session) {
              await this.sendMessage(chatId, `
üìã *WalletConnect URI*

\`${session.connector.uri}\`

**How to use:**
1. Copy the URI above
2. Open your wallet app
3. Find "WalletConnect" or "Connect to DApp"
4. Paste the URI
5. Approve the connection

‚è∞ *Expires in:* 5 minutes

üí° *Tip:* Use the web interface for easier connection!
              `);
            }
          }
          break;

        case 'connection_help':
          await this.sendMessage(chatId, `
‚ùì *Connection Help*

**Recommended Method:**
üöÄ Use the "Connect Wallet (One-Click)" button - it opens a web interface that:
‚Ä¢ Auto-detects your device
‚Ä¢ Provides one-click wallet connections
‚Ä¢ Shows QR codes for mobile wallets
‚Ä¢ Guides you through each step

**Manual Method:**
üìã Copy the WalletConnect URI and paste it in your wallet app

**Troubleshooting:**
‚Ä¢ Make sure your wallet app is updated
‚Ä¢ Check you're on the correct network (${config.networkName})
‚Ä¢ Try refreshing if connection fails
‚Ä¢ Use QR code scanning when available

**Supported Wallets:**
ü¶ä MetaMask ‚Ä¢ üõ°Ô∏è Trust Wallet ‚Ä¢ üåà Rainbow
üî∑ Argent ‚Ä¢ üíô imToken ‚Ä¢ And many more!
          `);
          break;

        default:
          if (data.startsWith('upgrade_')) {
            const planId = data.split('_')[1];
            await this.handleUpgrade({ chat: { id: chatId }, from: { id: userId } }, [null, planId]);
          } else if (data.startsWith('validate_upgrade_')) {
            const planId = data.split('_')[2];
            await this.handleValidateUpgrade({ chat: { id: chatId }, from: { id: userId } }, [null, planId]);
          }
          break;
      }
    } catch (error) {
      console.error('Callback query error:', error);
      await this.sendMessage(chatId, '‚ùå Error processing request. Please try again.');
    }
  }

  async handleWalletConnected(userId, address, chainId) {
    try {
      // Prevent duplicate messages
      const sessionId = this.walletService.userSessions.get(userId);
      if (sessionId) {
        const session = this.walletService.sessions.get(sessionId);
        if (session && session.notificationSent) {
          console.log(`üì® Skipping duplicate notification for user ${userId}`);
          return;
        }
        if (session) {
          session.notificationSent = true;
        }
      }

      await this.sendMessage(userId, `
‚úÖ *Wallet Connected Successfully!*

üîó *Address:* \`${address}\`
üåê *Network:* ${chainId === config.chainId ? config.networkName : `Chain ID: ${chainId}`}

${chainId !== config.chainId ? 
  `‚ö†Ô∏è *Warning:* Please switch to ${config.networkName} (Chain ID: ${config.chainId})` : 
  'üü¢ *Ready to use!* You can now register or upgrade your membership.'
}

üí° *Available commands:*
‚Ä¢ \`/myinfo\` - View membership status
‚Ä¢ \`/allplans\` - Browse membership plans
‚Ä¢ \`/wallet\` - View wallet details
      `);

      // Update session to mark as connected
      if (sessionId) {
        const session = this.walletService.sessions.get(sessionId);
        if (session) {
          session.connected = true;
          session.address = address;
          session.chainId = chainId;
          session.lastActivity = Date.now();
          console.log(`‚úÖ Session ${sessionId} marked as connected for user ${userId}`);
        }
      }
      
    } catch (error) {
      console.error('Error notifying wallet connection:', error);
    }
  }

  async handleDisconnect(msg) {
    const chatId = msg.chat.id;
    const userId = msg.from.id;

    try {
      const result = await this.walletService.disconnectWallet(userId);
      
      if (result) {
        await this.sendMessage(chatId, `
‚úÖ *Wallet Disconnected*

Your wallet has been disconnected successfully.

üí° Use \`/connect\` to connect again
        `);
      } else {
        await this.sendMessage(chatId, '‚ùå No active wallet connection found');
      }
    } catch (error) {
      console.error('Disconnect error:', error);
      await this.sendMessage(chatId, `‚ùå Error disconnecting wallet: ${error.message}`);
    }
  }

  async handleWalletStatus(msg) {
    const chatId = msg.chat.id;
    const userId = msg.from.id;

    try {
      const connection = await this.walletService.checkConnection(userId);
      
      if (!connection.connected) {
        await this.sendMessage(chatId, `
‚ùå *No Wallet Connected*

${connection.reason || 'Please connect your wallet first'}

üí° Use \`/connect\` to connect your wallet
        `);
        return;
      }

      const balanceInfo = await this.contractService.getUSDTBalance(connection.address);
      const allowanceInfo = await this.contractService.getUSDTAllowance(connection.address);

      await this.sendMessage(chatId, `
‚úÖ *Wallet Connected*

üîó *Address:* \`${connection.address}\`
üåê *Network:* ${config.networkName} (Chain ID: ${connection.chainId})

üí∞ *USDT Balance:* ${balanceInfo.formatted} USDT
üîì *USDT Allowance:* ${allowanceInfo.formatted} USDT

üí° *Commands:*
‚Ä¢ \`/myinfo\` - View membership info
‚Ä¢ \`/allplans\` - View available plans
‚Ä¢ \`/disconnect\` - Disconnect wallet
      `);

    } catch (error) {
      console.error('Wallet status error:', error);
      await this.sendMessage(chatId, `‚ùå Error checking wallet status: ${error.message}`);
    }
  }

  // === MEMBER TRANSACTION HANDLERS ===

  async handleRegister(msg, match) {
    const chatId = msg.chat.id;
    const userId = msg.from.id;
    const planId = parseInt(match[1]);
    let uplineAddress = match[2];

    try {
      const connection = await this.walletService.checkConnection(userId);
      if (!connection.connected) {
        await this.sendMessage(chatId, `
‚ùå *Wallet Not Connected*

Please connect your wallet first:
\`/connect\`
        `);
        return;
      }

      if (!uplineAddress) {
        await this.sendMessage(chatId, '‚ùå Please specify upline address or use a valid invitation link');
        return;
      }

      await this.sendMessage(chatId, '‚è≥ Validating registration conditions...');
      
      try {
        await this.contractService.validateRegistration(connection.address, planId, uplineAddress);
      } catch (validationError) {
        await this.sendMessage(chatId, `‚ùå Validation failed: ${validationError.message}

üí° *Suggestions:*
‚Ä¢ Check if you're already a member with \`/myinfo\`
‚Ä¢ Ensure upline is a valid member
‚Ä¢ Check USDT balance with \`/wallet\`
‚Ä¢ Use \`/approve <amount>\` to approve USDT`);
        return;
      }

      const planInfo = await this.contractService.getPlanInfo(planId);
      const usdtDecimals = await this.contractService.usdtContract.decimals();
      const { ethers } = require('ethers');
      const priceFormatted = ethers.formatUnits(planInfo.price, usdtDecimals);

      const txData = this.contractService.buildRegisterTransaction(planId, uplineAddress);
      
      await this.sendMessage(chatId, `
üí° *Ready to Register*

üìã *Details:*
‚Ä¢ Plan: ${planInfo.name} (Plan ${planId})
‚Ä¢ Price: ${priceFormatted} USDT
‚Ä¢ Upline: \`${uplineAddress}\`

‚è≥ Sending transaction request to your wallet...
      `);

      const result = await this.walletService.sendTransaction(
        userId, 
        txData, 
        `Register Plan ${planId}`
      );

      if (result.success) {
        await this.sendMessage(chatId, `
‚úÖ *Transaction Sent Successfully!*

üìÑ *Transaction Hash:* \`${result.txHash}\`
üîó *Explorer:* [View Transaction](${this.contractService.getExplorerUrl(result.txHash)})

‚è≥ *Status:* Waiting for confirmation...

üí° Use \`/txstatus ${result.txHash}\` to check status
        `);

        this.monitorTransaction(chatId, result.txHash, 'registration');
      }

    } catch (error) {
      console.error('Register error:', error);
      await this.sendMessage(chatId, `‚ùå Registration failed: ${error.message}`);
    }
  }

  async handleUpgrade(msg, match) {
    const chatId = msg.chat.id;
    const userId = msg.from.id;
    const newPlanId = parseInt(match[1]);

    try {
      const connection = await this.walletService.checkConnection(userId);
      if (!connection.connected) {
        await this.sendMessage(chatId, `
‚ùå *Wallet Not Connected*

Please connect your wallet first:
\`/connect\`
        `);
        return;
      }

      await this.sendMessage(chatId, '‚è≥ Validating upgrade conditions...');
      
      let validation;
      try {
        validation = await this.contractService.validateUpgrade(connection.address, newPlanId);
      } catch (validationError) {
        await this.sendMessage(chatId, `‚ùå Cannot upgrade: ${validationError.message}

üí° *Suggestions:*
‚Ä¢ Use \`/myinfo\` to view current status
‚Ä¢ Use \`/allplans\` to view available plans
‚Ä¢ Use \`/approve <amount>\` if USDT is insufficient`);
        return;
      }

      const { ethers } = require('ethers');
      const usdtDecimals = await this.contractService.usdtContract.decimals();
      const newPlanPrice = ethers.formatUnits(validation.newPlanInfo.price, usdtDecimals);
      const upgradeCost = ethers.formatUnits(validation.upgradeCost, usdtDecimals);

      const txData = this.contractService.buildUpgradeTransaction(newPlanId);

      await this.sendMessage(chatId, `
üí° *Ready to Upgrade*

üìã *Details:*
‚Ä¢ Current Plan: Plan ${validation.currentPlan}
‚Ä¢ New Plan: ${validation.newPlanInfo.name} (Plan ${newPlanId})
‚Ä¢ New Plan Price: ${newPlanPrice} USDT
‚Ä¢ Upgrade Cost: ${upgradeCost} USDT

‚è≥ Sending transaction request to your wallet...
      `);

      const result = await this.walletService.sendTransaction(
        userId,
        txData,
        `Upgrade to Plan ${newPlanId}`
      );

      if (result.success) {
        await this.sendMessage(chatId, `
‚úÖ *Transaction Sent Successfully!*

üìÑ *Transaction Hash:* \`${result.txHash}\`
üîó *Explorer:* [View Transaction](${this.contractService.getExplorerUrl(result.txHash)})

‚è≥ *Status:* Waiting for confirmation...

üí° Use \`/txstatus ${result.txHash}\` to check status
        `);

        this.monitorTransaction(chatId, result.txHash, 'upgrade');
      }

    } catch (error) {
      console.error('Upgrade error:', error);
      await this.sendMessage(chatId, `‚ùå Upgrade failed: ${error.message}`);
    }
  }

  async handleApproveUSDT(msg, match) {
  const chatId = msg.chat.id;
  const userId = msg.from.id;
  const amount = match[1];

  try {
    const connection = await this.walletService.checkConnection(userId);
    if (!connection.connected) {
      await this.sendMessage(chatId, '√¢≈í Please connect your wallet first: `/connect`');
      return;
    }

    const amountWei = await this.contractService.parsePrice(amount);
    const txData = this.contractService.buildApproveTransaction(amountWei);

    await this.sendMessage(chatId, `
üí° *Ready to Approve USDT*

üìã *Details:*
‚Ä¢ Amount: ${amount} USDT
‚Ä¢ Contract: \`${config.contractAddress}\`

‚è≥ Sending approval request to your wallet...
    `);

    const result = await this.walletService.sendTransaction(
      userId,
      txData,
      `Approve ${amount} USDT`
    );

    if (result.success) {
      // ‡∏î‡∏∂‡∏á session ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏™‡∏£‡πâ‡∏≤‡∏á universal links
      const sessionId = this.walletService.userSessions.get(userId);
      const session = sessionId ? this.walletService.sessions.get(sessionId) : null;
      
      const keyboard = {
        inline_keyboard: []
      };

      // ‡∏™‡∏£‡πâ‡∏≤‡∏á Universal Links ‡∏ó‡∏µ‡πà Telegram ‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö
      if (session && session.connector.uri) {
        const encodedURI = encodeURIComponent(session.connector.uri);
        
        // Universal Links ‡∏ó‡∏µ‡πà‡πÉ‡∏ä‡πâ HTTPS (Telegram ‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö)
        keyboard.inline_keyboard.push([
          { 
            text: 'ü¶ä Open MetaMask', 
            url: `https://metamask.app.link/wc?uri=${encodedURI}` 
          }
        ]);
        
        keyboard.inline_keyboard.push([
          { 
            text: 'üõ°Ô∏è Trust Wallet', 
            url: `https://link.trustwallet.com/wc?uri=${encodedURI}` 
          },
          { 
            text: 'üåà Rainbow', 
            url: `https://rnbwapp.com/wc?uri=${encodedURI}` 
          }
        ]);

        // ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏õ‡∏∏‡πà‡∏° fallback
        keyboard.inline_keyboard.push([
          { 
            text: 'üì± Open Any Wallet', 
            url: `https://walletconnect.com/registry?uri=${encodedURI}` 
          }
        ]);
      }

      await this.sendMessage(chatId, `
‚úÖ *Transaction Request Sent!*

üì± *Quick Wallet Access:*
‚Ä¢ Tap buttons below to open your wallet app
‚Ä¢ Or manually switch to your wallet app
‚Ä¢ Approve the pending transaction

üìÑ *Transaction Hash:* \`${result.txHash}\`
üîó *Explorer:* [View Transaction](${this.contractService.getExplorerUrl(result.txHash)})

üí° *Manual Steps:*
1Ô∏è‚É£ Open your wallet app (MetaMask, Trust, etc.)
2Ô∏è‚É£ Look for "WalletConnect" or pending requests
3Ô∏è‚É£ Tap "Approve" to confirm the transaction

‚è∞ Use \`/txstatus ${result.txHash}\` to check status
      `, { reply_markup: keyboard });

      this.monitorTransaction(chatId, result.txHash, 'approval');
    }

  } catch (error) {
    console.error('Approve error:', error);
    await this.sendMessage(chatId, `‚ùå Approval failed: ${error.message}`);
  }
}

  // === TRANSACTION MONITORING ===

  async monitorTransaction(chatId, txHash, txType) {
    try {
      const status = await this.contractService.waitForTransactionConfirmation(txHash);
      
      if (status.status === 'success') {
        let message = `
‚úÖ *${txType.charAt(0).toUpperCase() + txType.slice(1)} Successful!*

üìÑ *Transaction Hash:* \`${txHash}\`
üîó *Explorer:* [View Transaction](${status.explorerUrl})
‚õΩ *Gas Used:* ${status.gasUsed}
üß± *Block:* ${status.blockNumber}
        `;

        if (txType === 'registration' || txType === 'upgrade') {
          message += `\nüí° Use \`/myinfo\` to view updated membership info`;
        }

        await this.sendMessage(chatId, message);
      }
    } catch (error) {
      await this.sendMessage(chatId, `
‚ùå *Transaction Monitoring Failed*

üìÑ *Transaction Hash:* \`${txHash}\`
‚ùì *Error:* ${error.message}

üîó Please check transaction status manually:
${this.contractService.getExplorerUrl(txHash)}
      `);
    }
  }

  async handleTransactionStatus(msg, match) {
    const chatId = msg.chat.id;
    const txHash = match[1];

    try {
      const status = await this.contractService.checkTransactionStatus(txHash);
      
      let statusEmoji;
      switch (status.status) {
        case 'success':
          statusEmoji = '‚úÖ';
          break;
        case 'failed':
          statusEmoji = '‚ùå';
          break;
        case 'pending':
          statusEmoji = '‚è≥';
          break;
        default:
          statusEmoji = '‚ùì';
      }

      let message = `
${statusEmoji} *Transaction Status*

üìÑ *Hash:* \`${txHash}\`
üìä *Status:* ${status.status.toUpperCase()}
üí¨ *Message:* ${status.message}
      `;

      if (status.explorerUrl) {
        message += `\nüîó *Explorer:* [View Transaction](${status.explorerUrl})`;
      }

      if (status.blockNumber) {
        message += `\nüß± *Block:* ${status.blockNumber}`;
      }

      if (status.gasUsed) {
        message += `\n‚õΩ *Gas Used:* ${status.gasUsed}`;
      }

      await this.sendMessage(chatId, message);

    } catch (error) {
      console.error('Transaction status error:', error);
      await this.sendMessage(chatId, `‚ùå Error checking transaction status: ${error.message}`);
    }
  }

  // === INFORMATION HANDLERS ===

  async handleStart(msg, match) {
    const chatId = msg.chat.id;
    const refAddress = match?.[1];

    if (refAddress) {
      await this.sendMessage(chatId, `üü¢ You were invited by \`${refAddress}\`\nThe system will use this as upline when you register`);
    } else {
      await this.sendMessage(chatId, `
üü¢ *Welcome to Crypto Membership!*

This bot helps you manage NFT membership on ${config.networkName} with secure wallet integration.

üöÄ *Getting Started:*
1Ô∏è‚É£ \`/connect\` - Connect your wallet securely
2Ô∏è‚É£ \`/myinfo\` - Check member status
3Ô∏è‚É£ \`/register 1 <upline_address>\` - Register membership

üìã *Main Commands:*
‚Ä¢ \`/help\` - Show all commands
‚Ä¢ \`/wallet\` - View wallet info
‚Ä¢ \`/allplans\` - View all plans
‚Ä¢ \`/contractstatus\` - Check system status

üîí *Security:*
‚úÖ Your private keys never leave your wallet
‚úÖ All transactions signed securely in your wallet app
‚úÖ WalletConnect standard used for maximum security

üí° Type \`/help\` to see all commands
      `);
    }
  }

  async handleHelp(msg) {
    const chatId = msg.chat.id;

    const helpMessage = `
ü§ñ *Crypto Membership Bot Help*

Secure NFT membership system on ${config.networkName} with WalletConnect integration.

üîó *Wallet Connection*
‚Ä¢ \`/connect\` - Connect wallet via WalletConnect
‚Ä¢ \`/disconnect\` - Disconnect wallet
‚Ä¢ \`/wallet\` - View wallet status & balance

üë§ *Registration / Upgrade*
‚Ä¢ \`/register <plan> <upline>\` - Register new membership
‚Ä¢ \`/upgrade <plan>\` - Upgrade membership plan
‚Ä¢ \`/myinfo\` - View your membership info

üìã *Plan Information*
‚Ä¢ \`/planinfo <id>\` - View specific plan info
‚Ä¢ \`/allplans\` - Show all active plans

üí∞ *USDT Management*
‚Ä¢ \`/approve <amount>\` - Approve USDT to contract
‚Ä¢ \`/usdtbalance\` - Check your USDT balance

üìÑ *Transaction Tracking*
‚Ä¢ \`/txstatus <hash>\` - Check transaction status

ü§ù *Referral (Invite Friends)*
‚Ä¢ \`/getreferrallink\` - Get invitation link

üîß *System Status*
‚Ä¢ \`/contractstatus\` - Check system status

üîç *Validation Commands*
‚Ä¢ \`/validate <plan> <upline>\` - Validate before registration
‚Ä¢ \`/validateupgrade <plan>\` - Validate before upgrade

üìñ **Usage Examples**
\`/connect\`
\`/register 1 0xABCD...\`
\`/approve 5\`
\`/upgrade 2\`

‚ö†Ô∏è **Security Features:**
‚úÖ WalletConnect integration - no private keys shared
‚úÖ Mobile & Desktop support
‚úÖ Multiple wallet support (MetaMask, Trust, etc.)

üåê **Network:**
‚Ä¢ Network: ${config.networkName}
‚Ä¢ Contract: \`${config.contractAddress}\`
  `;

    await this.sendMessage(chatId, helpMessage);
  }

  async handleMyInfo(msg) {
    const chatId = msg.chat.id;
    const userId = msg.from.id;

    try {
      const connection = await this.walletService.checkConnection(userId);
      if (!connection.connected) {
        await this.sendMessage(chatId, `
‚ùå *Wallet Not Connected*

Please connect your wallet first:
\`/connect\`
        `);
        return;
      }

      const memberInfo = await this.contractService.getMemberInfo(connection.address);

      if (!memberInfo.isMember) {
        await this.sendMessage(chatId, `
‚ùå *Not a Member Yet*

You are not a member of the system yet.

üí° *How to get started:*
‚Ä¢ \`/allplans\` - View available plans
‚Ä¢ \`/register 1 <upline_address>\` - Register for Plan 1

üìù New members must start from Plan 1
        `);
        return;
      }

      const planInfo = await this.contractService.getPlanInfo(parseInt(memberInfo.planId));
      const usdtDecimals = await this.contractService.usdtContract.decimals();
      const { ethers } = require('ethers');
      const earningsFormatted = ethers.formatUnits(memberInfo.totalEarnings, usdtDecimals);
      const registeredDate = new Date(parseInt(memberInfo.registeredAt) * 1000).toLocaleString('en-US');

      const currentPlan = parseInt(memberInfo.planId);
      const nextPlan = currentPlan + 1;
      const totalPlans = await this.contractService.getTotalPlanCount();
      const canUpgrade = nextPlan <= parseInt(totalPlans);

      let upgradeMessage = '';
      if (canUpgrade) {
        upgradeMessage = `\nüí° *Available Actions:*\n‚Ä¢ \`/upgrade ${nextPlan}\` - Upgrade to Plan ${nextPlan}\n‚Ä¢ \`/planinfo ${nextPlan}\` - View Plan ${nextPlan} info`;
      } else {
        upgradeMessage = `\nüèÜ *Congratulations! You are on the highest plan!*`;
      }

      await this.sendMessage(chatId, `
üë§ *Your Membership Info*

üîó *Wallet:* \`${connection.address}\`

üìã *Membership Details:*
‚Ä¢ Current Plan: ${planInfo.name} (Plan ${memberInfo.planId})
‚Ä¢ Cycle: ${memberInfo.cycleNumber}
‚Ä¢ Upline: \`${memberInfo.upline}\`

üí∞ *Statistics:*
‚Ä¢ Total Earnings: ${earningsFormatted} USDT
‚Ä¢ Total Referrals: ${memberInfo.totalReferrals} people
‚Ä¢ Registration Date: ${registeredDate}${upgradeMessage}
      `);

    } catch (error) {
      console.error('MyInfo error:', error);
      await this.sendMessage(chatId, `‚ùå Error retrieving member info: ${error.message}`);
    }
  }

  async handlePlanInfo(msg, match) {
    const chatId = msg.chat.id;
    const userId = msg.from.id;
    const planId = parseInt(match[1]);

    try {
      if (!planId || planId < 1) {
        await this.sendMessage(chatId, '‚ùå Invalid Plan ID');
        return;
      }

      const planInfo = await this.contractService.getPlanInfo(planId);
      const { ethers } = require('ethers');
      const usdtDecimals = await this.contractService.usdtContract.decimals();
      const priceFormatted = ethers.formatUnits(planInfo.price, usdtDecimals);

      let memberInfo = null;
      let isExistingMember = false;
      let userAddress = null;

      const connection = await this.walletService.checkConnection(userId);
      if (connection.connected) {
        try {
          userAddress = connection.address;
          memberInfo = await this.contractService.getMemberInfo(userAddress);
          isExistingMember = memberInfo.isMember;
        } catch (error) {
          // Ignore error
        }
      }

      let actionMessage = '';
      let keyboard = null;

      if (!connection.connected) {
        actionMessage = `\nüí° *Get Started:*\n\`/connect\` - Connect wallet to register`;
      } else if (isExistingMember) {
        const currentPlan = parseInt(memberInfo.planId);
        const targetPlan = planId;

        if (targetPlan === currentPlan) {
          actionMessage = `\n‚úÖ *You are currently on this plan*`;
        } else if (targetPlan === currentPlan + 1) {
          actionMessage = `\nüí° *Ready to upgrade:*`;
          keyboard = {
            inline_keyboard: [
              [{ text: `‚¨ÜÔ∏è Upgrade to Plan ${planId}`, callback_data: `upgrade_${planId}` }],
              [{ text: 'üîç Validate First', callback_data: `validate_upgrade_${planId}` }]
            ]
          };
        } else if (targetPlan > currentPlan + 1) {
          actionMessage = `\n‚ö†Ô∏è *Must upgrade one plan at a time*\nYou are on Plan ${currentPlan}, must upgrade to Plan ${currentPlan + 1} first`;
        } else {
          actionMessage = `\n‚¨áÔ∏è *This plan is lower than your current plan (${currentPlan})*`;
        }
      } else {
        if (planId === 1) {
          actionMessage = `\nüí° *Ready to register:*`;
          keyboard = {
            inline_keyboard: [
              [{ text: 'üìù How to Register', callback_data: 'how_to_register' }]
            ]
          };
        } else {
          actionMessage = `\n‚ö†Ô∏è *New members must start from Plan 1 only*\nUse command: \`/planinfo 1\``;
        }
      }

      await this.sendMessage(chatId, `
üìä *Plan ${planId} Information*

üìã *Details:*
‚Ä¢ Plan Name: ${planInfo.name}
‚Ä¢ Price: ${priceFormatted} USDT
‚Ä¢ Members per Cycle: ${planInfo.membersPerCycle} people
‚Ä¢ Status: ${planInfo.isActive ? 'üü¢ Active' : 'üî¥ Inactive'}${actionMessage}
      `, keyboard ? { reply_markup: keyboard } : {});

    } catch (error) {
      console.error('PlanInfo error:', error);
      await this.sendMessage(chatId, `‚ùå Error retrieving plan info: ${error.message}`);
    }
  }

  async handleTotalPlans(msg) {
    const chatId = msg.chat.id;

    try {
      const totalPlans = await this.contractService.getTotalPlanCount();
      await this.sendMessage(chatId, `üìä Total membership plans: *${totalPlans}* plans\n\nUse \`/allplans\` to view details of all plans`);
    } catch (error) {
      console.error('TotalPlans error:', error);
      await this.sendMessage(chatId, `‚ùå Error retrieving total plans: ${error.message}`);
    }
  }

  async handleAllPlans(msg) {
    const chatId = msg.chat.id;
    const userId = msg.from.id;

    try {
      const totalPlans = await this.contractService.getTotalPlanCount();
      const { ethers } = require('ethers');
      const usdtDecimals = await this.contractService.usdtContract.decimals();

      let message = 'üìä *All Membership Plans*\n\n';

      for (let i = 1; i <= parseInt(totalPlans); i++) {
        try {
          const planInfo = await this.contractService.getPlanInfo(i);
          const priceFormatted = ethers.formatUnits(planInfo.price, usdtDecimals);
          const status = planInfo.isActive ? 'üü¢' : 'üî¥';

          message += `${status} *Plan ${i}: ${planInfo.name}*\n`;
          message += `   üí∞ ${priceFormatted} USDT\n`;
          message += `   üë• ${planInfo.membersPerCycle} people/cycle\n\n`;
        } catch (error) {
          message += `‚ùå Plan ${i}: Unable to load data\n\n`;
        }
      }

      const connection = await this.walletService.checkConnection(userId);
      if (connection.connected) {
        try {
          const memberInfo = await this.contractService.getMemberInfo(connection.address);

          if (memberInfo.isMember) {
            const currentPlan = parseInt(memberInfo.planId);
            const nextPlan = currentPlan + 1;

            message += `\nüë§ *Your Status:*\n`;
            message += `‚Ä¢ Current Plan: Plan ${currentPlan}\n`;

            if (nextPlan <= parseInt(totalPlans)) {
              message += `‚Ä¢ Next Upgrade: \`/upgrade ${nextPlan}\`\n`;
            } else {
              message += `‚Ä¢ You are on the highest plan! üèÜ\n`;
            }
          } else {
            message += `\nüë§ *Get Started:*\n`;
            message += `‚Ä¢ Register: \`/register 1 <upline_address>\`\n`;
          }
        } catch (error) {
          // Ignore error
        }
      } else {
        message += `\nüë§ *Get Started:*\n`;
        message += `‚Ä¢ Connect Wallet: \`/connect\`\n`;
      }

      await this.sendMessage(chatId, message);
    } catch (error) {
      console.error('AllPlans error:', error);
      await this.sendMessage(chatId, `‚ùå Error retrieving plans: ${error.message}`);
    }
  }

  async handleContractStatus(msg) {
    const chatId = msg.chat.id;

    try {
      const isPaused = await this.contractService.isContractPaused();
      const owner = await this.contractService.getContractOwner();
      const networkInfo = await this.contractService.getNetworkInfo();

      await this.sendMessage(chatId, `
üîß *Contract Status*

üìã *Contract Details:*
‚Ä¢ Status: ${isPaused ? 'üî¥ Paused' : 'üü¢ Active'}
‚Ä¢ Owner: \`${owner}\`
‚Ä¢ Contract: \`${config.contractAddress}\`

üåê *Network Information:*
‚Ä¢ Network: ${config.networkName}
‚Ä¢ Chain ID: ${networkInfo.chainId}
‚Ä¢ Current Block: ${networkInfo.blockNumber}
‚Ä¢ Gas Price: ${ethers.formatUnits(networkInfo.gasPrice || '0', 'gwei')} Gwei

üîó *Explorer:* [View Contract](${config.explorerUrl}/address/${config.contractAddress})
      `);

    } catch (error) {
      console.error('ContractStatus error:', error);
      await this.sendMessage(chatId, `‚ùå Error retrieving contract status: ${error.message}`);
    }
  }

  async handleUSDTBalance(msg) {
    const chatId = msg.chat.id;
    const userId = msg.from.id;

    try {
      const connection = await this.walletService.checkConnection(userId);
      if (!connection.connected) {
        await this.sendMessage(chatId, `
‚ùå *Wallet Not Connected*

Please connect your wallet first:
\`/connect\`
        `);
        return;
      }

      const balanceInfo = await this.contractService.getUSDTBalance(connection.address);
      const allowanceInfo = await this.contractService.getUSDTAllowance(connection.address);

      await this.sendMessage(chatId, `
üí∞ *USDT Information*

üîó *Wallet:* \`${connection.address}\`

üí≥ *Balance Details:*
‚Ä¢ USDT Balance: ${balanceInfo.formatted} USDT
‚Ä¢ USDT Allowance: ${allowanceInfo.formatted} USDT

üìù *Note:*
‚Ä¢ Balance: Available USDT in your wallet
‚Ä¢ Allowance: USDT approved for contract usage

üí° *Commands:*
‚Ä¢ \`/approve <amount>\` - Approve more USDT
‚Ä¢ \`/wallet\` - View complete wallet info
      `);

    } catch (error) {
      console.error('USDTBalance error:', error);
      await this.sendMessage(chatId, `‚ùå Error retrieving USDT info: ${error.message}`);
    }
  }

  async handleValidateRegistration(msg, match) {
    const chatId = msg.chat.id;
    const userId = msg.from.id;
    const planId = parseInt(match[1]);
    const uplineAddress = match[2];

    try {
      const connection = await this.walletService.checkConnection(userId);
      if (!connection.connected) {
        await this.sendMessage(chatId, '‚ùå Please connect your wallet first: `/connect`');
        return;
      }

      await this.sendMessage(chatId, '‚è≥ Validating registration conditions...');

      await this.contractService.validateRegistration(connection.address, planId, uplineAddress);

      await this.sendMessage(chatId, `
‚úÖ *All validations passed!*

üìã *Details:*
‚Ä¢ Wallet: \`${connection.address}\`
‚Ä¢ Plan: ${planId}
‚Ä¢ Upline: \`${uplineAddress}\`

üü¢ Ready to register! Use command:
\`/register ${planId} ${uplineAddress}\`
      `);

    } catch (error) {
      console.error('ValidateRegistration error:', error);
      await this.sendMessage(chatId, `‚ùå Validation failed: ${error.message}

üí° *Suggestions:*
‚Ä¢ Check if you're already a member with \`/myinfo\`
‚Ä¢ Ensure upline is a valid member
‚Ä¢ Check USDT balance with \`/wallet\`
‚Ä¢ Use \`/approve <amount>\` to approve USDT`);
    }
  }

  async handleValidateUpgrade(msg, match) {
    const chatId = msg.chat.id;
    const userId = msg.from.id;
    const newPlanId = parseInt(match[1]);

    try {
      const connection = await this.walletService.checkConnection(userId);
      if (!connection.connected) {
        await this.sendMessage(chatId, '‚ùå Please connect your wallet first: `/connect`');
        return;
      }

      await this.sendMessage(chatId, '‚è≥ Validating upgrade conditions...');

      const validation = await this.contractService.validateUpgrade(connection.address, newPlanId);

      const usdtDecimals = await this.contractService.usdtContract.decimals();
      const { ethers } = require('ethers');
      const upgradeCost = ethers.formatUnits(validation.upgradeCost, usdtDecimals);
      const newPlanPrice = ethers.formatUnits(validation.newPlanInfo.price, usdtDecimals);

      await this.sendMessage(chatId, `
‚úÖ *All validations passed!*

üìã *Details:*
‚Ä¢ Wallet: \`${connection.address}\`
‚Ä¢ Current Plan: Plan ${validation.currentPlan}
‚Ä¢ New Plan: ${validation.newPlanInfo.name} (Plan ${newPlanId})
‚Ä¢ New Plan Price: ${newPlanPrice} USDT
‚Ä¢ Upgrade Cost: ${upgradeCost} USDT

üü¢ Ready to upgrade! Use command:
\`/upgrade ${newPlanId}\`
      `);

    } catch (error) {
      console.error('ValidateUpgrade error:', error);
      await this.sendMessage(chatId, `‚ùå Validation failed: ${error.message}

üí° *Suggestions:*
‚Ä¢ Check if you are already a member with \`/myinfo\`
‚Ä¢ Ensure you upgrade one plan at a time
‚Ä¢ Check USDT balance and allowance with \`/wallet\`
‚Ä¢ Use \`/approve <amount>\` if allowance is insufficient`);
    }
  }

  async handleReferralLink(msg) {
    const userId = msg.from.id;

    try {
      const connection = await this.walletService.checkConnection(userId);
      if (!connection.connected) {
        await this.sendMessage(msg.chat.id, '‚ùå Please connect your wallet first: `/connect`');
        return;
      }

      const botUsername = this.me && this.me.username ? this.me.username : 'ChainsxCo_bot';
      const refLink = `https://t.me/${botUsername}?start=ref_${connection.address}`;

      await this.sendMessage(msg.chat.id, `
üîó *Your Invitation Link*

${refLink}

üìã *How to use:*
‚Ä¢ Share this link with friends
‚Ä¢ When they click and start the bot, your address will be automatically set as their upline
‚Ä¢ You'll earn commissions when they register and upgrade

üí∞ *Benefits:*
‚Ä¢ Earn from direct referrals
‚Ä¢ Build your downline network
‚Ä¢ Passive income from team activities
      `);

    } catch (error) {
      console.error('ReferralLink error:', error);
      await this.sendMessage(msg.chat.id, `‚ùå Error generating referral link: ${error.message}`);
    }
  }

  start() {
    console.log('ü§ñ User Bot started with WalletConnect integration!');
    console.log(`üåê Network: ${config.networkName}`);
    console.log(`üìÑ Contract: ${config.contractAddress}`);
    console.log(`üîó WalletConnect bridge: https://bridge.walletconnect.org`);
    console.log(`üåê API Server: http://localhost:3001`);
    console.log('‚úÖ User Bot ready to receive commands...');
  }
}

module.exports = TelegramMembershipBot;